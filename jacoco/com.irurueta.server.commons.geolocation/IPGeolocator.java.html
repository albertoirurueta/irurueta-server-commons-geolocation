<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IPGeolocator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-server-commons-geolocation</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.server.commons.geolocation</a> &gt; <span class="el_source">IPGeolocator.java</span></div><h1>IPGeolocator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2016 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.server.commons.geolocation;

import com.maxmind.db.CHMCache;
import com.maxmind.geoip2.DatabaseReader;
import com.maxmind.geoip2.exception.GeoIp2Exception;
import com.maxmind.geoip2.model.AbstractCountryResponse;
import com.maxmind.geoip2.model.CityResponse;
import com.maxmind.geoip2.record.City;
import com.maxmind.geoip2.record.Continent;
import com.maxmind.geoip2.record.Country;
import com.maxmind.geoip2.record.Location;
import com.maxmind.geoip2.record.Postal;
import com.maxmind.geoip2.record.Subdivision;
import com.maxmind.geoip2.record.Traits;

import java.io.Closeable;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.ref.SoftReference;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.List;
import java.util.TimeZone;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Class to locate an IP address.
 */
public class IPGeolocator implements Closeable {

    /**
     * Logger of this class.
     */
<span class="fc" id="L55">    private static final Logger LOGGER = Logger.getLogger(</span>
<span class="fc" id="L56">            IPGeolocator.class.getName());</span>

    /**
     * Buffer size to copy embedded databases into final locations.
     */
    private static final int BUFFER_SIZE = 1024;

    /**
     * Singleton instance of IPGeolocator.
     */
    private static SoftReference&lt;IPGeolocator&gt; mReference;

    /**
     * Indicates if geolocation is enabled.
     */
    private boolean mEnabled;

    /**
     * Reference to geolocation configuration.
     */
    private GeolocationConfiguration mConfiguration;

    /**
     * City database reader.
     */
    private DatabaseReader mCityReader;

    /**
     * Indicates whether city database has already been prepared.
     */
    private boolean mCityDatabasePrepared;

    /**
     * Country database reader.
     */
    private DatabaseReader mCountryReader;

    /**
     * Indicates whether country database has already been prepared.
     */
    private boolean mCountryDatabasePrepared;

    /**
     * Constructor.
     * Creates and configures an IPGeolocator instance.
     */
<span class="fc" id="L102">    private IPGeolocator() {</span>
<span class="fc" id="L103">        mEnabled = false;</span>
        try {
<span class="fc" id="L105">            mConfiguration = GeolocationConfigurationFactory.getInstance().</span>
<span class="fc" id="L106">                    configure();</span>


            // copy embedded databases to destination if needed
<span class="fc" id="L110">            prepareDatabases();</span>

            // configure lookup services
<span class="fc" id="L113">            final IPGeolocationLevel level = mConfiguration.getIPGeolocationLevel();</span>

<span class="pc bpc" id="L115" title="1 of 2 branches missed.">            if (level != null) {</span>
<span class="fc bfc" id="L116" title="All 2 branches covered.">                if (level == IPGeolocationLevel.CITY) {</span>
<span class="fc" id="L117">                    mCityReader = createCityReader();</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">                } else if (level == IPGeolocationLevel.COUNTRY) {</span>
<span class="fc" id="L119">                    mCountryReader = createCountryReader();</span>
                }

<span class="fc bfc" id="L122" title="All 4 branches covered.">                if (mCityReader != null || mCountryReader != null) {</span>
<span class="fc" id="L123">                    mEnabled = true;</span>
                }
            }

<span class="nc" id="L127">        } catch (final Exception e) {</span>
<span class="nc" id="L128">            LOGGER.log(Level.WARNING, &quot;IP geolocation configuration not completed&quot;, e);</span>
        } finally {
<span class="fc bfc" id="L130" title="All 2 branches covered.">            if (mEnabled) {</span>
<span class="fc" id="L131">                LOGGER.log(Level.INFO, &quot;IP geolocation configured&quot;);</span>
            } else {
<span class="fc" id="L133">                LOGGER.log(Level.INFO, &quot;IP geolocation is disabled&quot;);</span>
            }
        }
<span class="fc" id="L136">    }</span>

    /**
     * Factory method to return the singleton instance of IPGeolocator based
     * on current configuration.
     *
     * @return singleton instance.
     */
    public static synchronized IPGeolocator getInstance() {
        IPGeolocator singleton;
<span class="pc bpc" id="L146" title="1 of 4 branches missed.">        if (mReference == null || (singleton = mReference.get()) == null) {</span>
<span class="fc" id="L147">            singleton = new IPGeolocator();</span>
<span class="fc" id="L148">            mReference = new SoftReference&lt;&gt;(singleton);</span>
        }
<span class="fc" id="L150">        return singleton;</span>
    }

    /**
     * Locates provided IP or IPv6 address using requested level.
     * Notice that geolocation levels are: Country, City (which includes country
     * information) and Disabled, which throws an exception.
     *
     * @param address IP address to evaluate.
     * @param level   level of accuracy of geolocation.
     * @return location of IP address.
     * @throws IPGeolocationDisabledException if IP geolocation is disabled or
     *                                        was not properly configured.
     * @throws IPLocationNotFoundException    if IP address couldn't be geolocated
     *                                        because it wasn't found in database.
     */
    public synchronized IPLocation locate(
            final InetAddress address,
            final IPGeolocationLevel level) throws IPGeolocationDisabledException,
            IPLocationNotFoundException {
<span class="pc bpc" id="L170" title="1 of 4 branches missed.">        if (!mEnabled || level == IPGeolocationLevel.DISABLED) {</span>
<span class="fc" id="L171">            throw new IPGeolocationDisabledException();</span>
        }

        try {
<span class="fc" id="L175">            final IPLocation location = new IPLocation(level);</span>
            DatabaseReader reader;

            // city level
<span class="fc bfc" id="L179" title="All 2 branches covered.">            if (level == IPGeolocationLevel.CITY) {</span>
<span class="fc" id="L180">                reader = getOrCreateCityReader();</span>

                // search at city level
<span class="fc" id="L183">                final CityResponse response = reader.city(address);</span>

                // city level
<span class="fc" id="L186">                final City city = response.getCity();</span>
<span class="pc bpc" id="L187" title="1 of 2 branches missed.">                if (city != null) {</span>
<span class="fc" id="L188">                    location.mCity = city.getName();</span>
                }

<span class="fc" id="L191">                final Location loc = response.getLocation();</span>
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">                if (loc != null) {</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">                    location.mTimeZone = loc.getTimeZone() != null ?</span>
<span class="fc" id="L194">                            TimeZone.getTimeZone(loc.getTimeZone()) : null;</span>
<span class="fc" id="L195">                    location.mAccuracyRadius = loc.getAccuracyRadius();</span>
<span class="fc" id="L196">                    location.mMetroCode = loc.getMetroCode();</span>
<span class="fc" id="L197">                    location.mLatitude = loc.getLatitude();</span>
<span class="fc" id="L198">                    location.mLongitude = loc.getLongitude();</span>
                }

<span class="fc" id="L201">                final Postal postal = response.getPostal();</span>
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">                if (postal != null) {</span>
<span class="fc" id="L203">                    location.mPostalCode = postal.getCode();</span>
                }

<span class="fc" id="L206">                final List&lt;Subdivision&gt; subdivisions = response.getSubdivisions();</span>
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">                if (subdivisions != null) {</span>
<span class="fc" id="L208">                    location.mSubdivisionCodes = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L209">                    location.mSubdivisionNames = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">                    for (final Subdivision s : subdivisions) {</span>
<span class="pc bpc" id="L211" title="2 of 4 branches missed.">                        if (s.getIsoCode() != null &amp;&amp; s.getName() != null) {</span>
<span class="fc" id="L212">                            location.mSubdivisionCodes.add(s.getIsoCode());</span>
<span class="fc" id="L213">                            location.mSubdivisionNames.add(s.getName());</span>
                        }
<span class="fc" id="L215">                    }</span>
                }


                // country level
<span class="fc" id="L220">                processCountryResponse(response, location);</span>
            }

            // country or city level (if nothing has been found yet)
<span class="fc bfc" id="L224" title="All 2 branches covered.">            if (level == IPGeolocationLevel.COUNTRY) {</span>
<span class="fc" id="L225">                reader = getOrCreateCountryReader();</span>
<span class="fc" id="L226">                final AbstractCountryResponse response = reader.country(address);</span>
<span class="fc" id="L227">                processCountryResponse(response, location);</span>
            }

<span class="fc" id="L230">            return location;</span>
<span class="fc" id="L231">        } catch (final GeoIp2Exception | IOException e) {</span>
<span class="fc" id="L232">            throw new IPLocationNotFoundException(e);</span>
        }
    }

    /**
     * Locates provided IP or IPv6 address using requested level.
     * Notice that geolocation levels are: Country, City (which includes country
     * information) and Organization (which includes both City and Country
     * information)
     *
     * @param address IP address or DNS host name to evaluate in string form.
     * @param level   level of accuracy of geolocation.
     * @return location of IP address.
     * @throws UnknownHostException           if provided textual form of IP address is
     *                                        not valid, or if DNS host name couldn't be resolved into an IP address.
     * @throws IPGeolocationDisabledException if IP geolocation is disabled or
     *                                        was not properly configured.
     * @throws IPLocationNotFoundException    if IP address couldn't be geolocated
     *                                        because it wasn't found in database.
     */
    public IPLocation locate(final String address, final IPGeolocationLevel level)
            throws UnknownHostException, IPGeolocationDisabledException,
            IPLocationNotFoundException {
<span class="fc" id="L255">        return locate(InetAddress.getByName(address), level);</span>
    }

    /**
     * Locates provided IP or IPv6 address using default configured geolocation
     * level of accuracy.
     *
     * @param address IP address to evaluate.
     * @return location of IP address.
     * @throws IPGeolocationDisabledException if IP geolocation is disabled or
     *                                        was not properly configured.
     * @throws IPLocationNotFoundException    if IP address couldn't be geolocated
     *                                        because it wasn't found in database.
     */
    public IPLocation locate(final InetAddress address)
            throws IPGeolocationDisabledException, IPLocationNotFoundException {
<span class="fc" id="L271">        return locate(address, mConfiguration.getIPGeolocationLevel());</span>
    }

    /**
     * Locates provided IP or IPv6 address using default configured geolocation
     * level of accuracy.
     *
     * @param address IP address or DNS host name to evaluate in string form
     * @return location of IP address.
     * @throws UnknownHostException           if provided textual form of IP address is
     *                                        not valid, or if DNS host name couldn't be resolved into an IP address.
     * @throws IPGeolocationDisabledException if IP geolocation is disabled or
     *                                        was not properly configured.
     * @throws IPLocationNotFoundException    if IP address couldn't be geolocated
     *                                        because it wasn't found in database.
     */
    public IPLocation locate(final String address) throws UnknownHostException,
            IPGeolocationDisabledException, IPLocationNotFoundException {
<span class="fc" id="L289">        return locate(InetAddress.getByName(address));</span>
    }

    /**
     * Closes location services. Once closed, geolocation will not be available.
     * If databases where embedded, then their destination local files will also
     * be deleted when closing location services.
     * This method should be called at server shutdown or when application is
     * undeployed.
     *
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public synchronized void close() throws IOException {
        // close location services
<span class="fc bfc" id="L304" title="All 2 branches covered.">        if (mCityReader != null) {</span>
            try {
<span class="fc" id="L306">                mCityReader.close();</span>
<span class="fc" id="L307">            } catch (final IOException e) {</span>
<span class="fc" id="L308">                LOGGER.log(Level.WARNING, &quot;Could not close city database&quot;, e);</span>
<span class="fc" id="L309">            }</span>
        }
<span class="fc bfc" id="L311" title="All 2 branches covered.">        if (mCountryReader != null) {</span>
            try {
<span class="fc" id="L313">                mCountryReader.close();</span>
<span class="fc" id="L314">            } catch (final IOException e) {</span>
<span class="fc" id="L315">                LOGGER.log(Level.WARNING, &quot;Could not close country database&quot;, e);</span>
<span class="fc" id="L316">            }</span>
        }

<span class="fc" id="L319">        mEnabled = false;</span>

        // delete database files if they were copied from embedded resources, as
        // this method will usually be called on server shutdown or application
        // undeployment
<span class="fc" id="L324">        boolean failed = false;</span>
<span class="fc bfc" id="L325" title="All 2 branches covered.">        if (mCountryDatabasePrepared) {</span>
            // delete country database file
<span class="fc" id="L327">            final File f = new File(</span>
<span class="fc" id="L328">                    mConfiguration.getIPGeolocationCountryDatabaseFile());</span>
<span class="fc bfc" id="L329" title="All 2 branches covered.">            if (f.exists()) {</span>
                try {
<span class="fc" id="L331">                    Files.delete(f.toPath());</span>
<span class="nc" id="L332">                } catch (final IOException e) {</span>
<span class="nc" id="L333">                    failed = true;</span>
<span class="fc" id="L334">                }</span>
            }
        }

        //city database
<span class="fc bfc" id="L339" title="All 2 branches covered.">        if (mCityDatabasePrepared) {</span>
            //delete city database file
<span class="fc" id="L341">            final File f = new File(</span>
<span class="fc" id="L342">                    mConfiguration.getIPGeolocationCityDatabaseFile());</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">            if (f.exists()) {</span>
                try {
<span class="fc" id="L345">                    Files.delete(f.toPath());</span>
<span class="nc" id="L346">                } catch (final IOException e) {</span>
<span class="nc" id="L347">                    failed = true;</span>
<span class="fc" id="L348">                }</span>
            }
        }

<span class="fc" id="L352">        mCityReader = mCountryReader = null;</span>

<span class="pc bpc" id="L354" title="1 of 2 branches missed.">        if (failed) {</span>
<span class="nc" id="L355">            throw new IOException();</span>
        }
<span class="fc" id="L357">    }</span>

    /**
     * Closes geolocation services if a configured IPGeolocator exists, and
     * resets the current singleton instance so a new one can be acquired having
     * a new configuration if required.
     *
     * @throws IOException if an I/O error occurs.
     */
    protected static synchronized void reset() throws IOException {
        final IPGeolocator singleton;
<span class="pc bpc" id="L368" title="1 of 4 branches missed.">        if (mReference != null &amp;&amp; (singleton = mReference.get()) != null) {</span>
<span class="fc" id="L369">            singleton.close();</span>
        }
<span class="fc" id="L371">        mReference = null;</span>
<span class="fc" id="L372">    }</span>

    /**
     * Gets or create city database reader.
     *
     * @return city database reader.
     * @throws IOException if an I/O error occurs.
     */
    private DatabaseReader getOrCreateCityReader() throws IOException {
<span class="fc bfc" id="L381" title="All 2 branches covered.">        if (mCityReader != null) {</span>
<span class="fc" id="L382">            return mCityReader;</span>
        } else {
<span class="fc" id="L384">            mCityReader = createCityReader();</span>
        }

<span class="fc" id="L387">        return mCityReader;</span>
    }

    /**
     * Gets or creates country database reader.
     *
     * @return country database reader.
     * @throws IOException if an I/O error occurs.
     */
    private DatabaseReader getOrCreateCountryReader() throws IOException {
<span class="fc bfc" id="L397" title="All 2 branches covered.">        if (mCountryReader != null) {</span>
<span class="fc" id="L398">            return mCountryReader;</span>
        } else {
<span class="fc" id="L400">            mCountryReader = createCountryReader();</span>
        }

<span class="fc" id="L403">        return mCountryReader;</span>
    }

    /**
     * Creates a city database reader.
     *
     * @return a city database reader.
     * @throws IOException if an I/O error occurs.
     */
    private DatabaseReader createCityReader() throws IOException {
<span class="fc bfc" id="L413" title="All 2 branches covered.">        if (!mCityDatabasePrepared) {</span>
<span class="fc" id="L414">            mCityDatabasePrepared = prepareCityDatabase();</span>
        }
<span class="fc" id="L416">        final File f = new File(mConfiguration.getIPGeolocationCityDatabaseFile());</span>
<span class="fc" id="L417">        return createReader(f);</span>
    }

    /**
     * Creates a country database reader.
     *
     * @return a country database reader.
     * @throws IOException if an I/O error occurs.
     */
    private DatabaseReader createCountryReader() throws IOException {
<span class="fc bfc" id="L427" title="All 2 branches covered.">        if (!mCountryDatabasePrepared) {</span>
<span class="fc" id="L428">            mCountryDatabasePrepared = prepareCountryDatabase();</span>
        }
<span class="fc" id="L430">        final File f = new File(mConfiguration.getIPGeolocationCountryDatabaseFile());</span>
<span class="fc" id="L431">        return createReader(f);</span>
    }

    /**
     * Creates a database reader.
     *
     * @param file file to read database from.
     * @return a database reader.
     * @throws IOException if an I/O error occurs.
     */
    private DatabaseReader createReader(final File file) throws IOException {
<span class="fc" id="L442">        final boolean cachingEnabled = mConfiguration.isCachingEnabled();</span>

<span class="fc" id="L444">        final DatabaseReader.Builder builder =</span>
                new DatabaseReader.Builder(file);
<span class="pc bpc" id="L446" title="1 of 2 branches missed.">        if (cachingEnabled) {</span>
<span class="fc" id="L447">            builder.withCache(new CHMCache());</span>
        }
<span class="fc" id="L449">        return builder.build();</span>
    }

    /**
     * Processes country level location data.
     *
     * @param response a response being processed.
     * @param location location where result will be stored.
     */
    private void processCountryResponse(final AbstractCountryResponse response,
                                        final IPLocation location) {
<span class="fc" id="L460">        final Continent continent = response.getContinent();</span>
<span class="pc bpc" id="L461" title="1 of 2 branches missed.">        if (continent != null) {</span>
<span class="fc" id="L462">            location.mContinentCode = continent.getCode();</span>
<span class="fc" id="L463">            location.mContinentName = continent.getName();</span>
        }

<span class="fc" id="L466">        Country country = response.getCountry();</span>
<span class="pc bpc" id="L467" title="1 of 2 branches missed.">        if (country != null) {</span>
<span class="fc" id="L468">            location.mCountryCode = country.getIsoCode();</span>
<span class="fc" id="L469">            location.mCountryName = country.getName();</span>
        }
<span class="fc" id="L471">        country = response.getRegisteredCountry();</span>
<span class="pc bpc" id="L472" title="1 of 2 branches missed.">        if (country != null) {</span>
<span class="fc" id="L473">            location.mRegisteredCountryCode = country.getIsoCode();</span>
<span class="fc" id="L474">            location.mRegisteredCountryName = country.getName();</span>
        }

<span class="fc" id="L477">        final Traits traits = response.getTraits();</span>
<span class="pc bpc" id="L478" title="1 of 2 branches missed.">        if (traits != null) {</span>
<span class="fc" id="L479">            location.mAutonomousSystemNumber =</span>
<span class="fc" id="L480">                    traits.getAutonomousSystemNumber();</span>
<span class="fc" id="L481">            location.mDomain = traits.getDomain();</span>
<span class="fc" id="L482">            location.mIsp = traits.getIsp();</span>
<span class="fc" id="L483">            location.mOrganization = traits.getOrganization();</span>
        }
<span class="fc" id="L485">    }</span>

    /**
     * Copies embedded resources into destination files where databases will be
     * stored locally.
     *
     * @throws IOException if an I/O error occurs.
     */
    private void prepareDatabases() throws IOException {

        // city database
<span class="fc" id="L496">        final IPGeolocationLevel level = mConfiguration.getIPGeolocationLevel();</span>
<span class="fc bfc" id="L497" title="All 2 branches covered.">        if (level == IPGeolocationLevel.CITY &amp;&amp;</span>
<span class="pc bpc" id="L498" title="1 of 2 branches missed.">                mConfiguration.isIPGeolocationCityDatabaseEmbedded() &amp;&amp;</span>
<span class="pc bpc" id="L499" title="1 of 2 branches missed.">                mConfiguration.getIPGeolocationCityEmbeddedResource() != null &amp;&amp;</span>
<span class="pc bpc" id="L500" title="1 of 2 branches missed.">                mConfiguration.getIPGeolocationCityDatabaseFile() != null) {</span>
<span class="fc" id="L501">            mCityDatabasePrepared = prepareCityDatabase();</span>
        }

        // country database
<span class="fc bfc" id="L505" title="All 2 branches covered.">        if (!mCityDatabasePrepared &amp;&amp;</span>
<span class="pc bpc" id="L506" title="1 of 2 branches missed.">                mConfiguration.isIPGeolocationCountryDatabaseEmbedded() &amp;&amp;</span>
<span class="pc bpc" id="L507" title="1 of 2 branches missed.">                mConfiguration.getIPGeolocationCountryEmbeddedResource() != null &amp;&amp;</span>
<span class="pc bpc" id="L508" title="1 of 2 branches missed.">                mConfiguration.getIPGeolocationCountryDatabaseFile() != null) {</span>
<span class="fc" id="L509">            mCountryDatabasePrepared = prepareCountryDatabase();</span>
        }
<span class="fc" id="L511">    }</span>

    /**
     * Copies embedded city resource into destination file where database will
     * be stored locally.
     *
     * @return true if database was prepared, false otherwise.
     * @throws IOException if an I/O error occurs.
     */
    private boolean prepareCityDatabase() throws IOException {
<span class="pc bpc" id="L521" title="1 of 2 branches missed.">        if (mConfiguration.isIPGeolocationCityDatabaseEmbedded() &amp;&amp;</span>
<span class="pc bpc" id="L522" title="1 of 2 branches missed.">                mConfiguration.getIPGeolocationCityEmbeddedResource() != null &amp;&amp;</span>
<span class="pc bpc" id="L523" title="1 of 2 branches missed.">                mConfiguration.getIPGeolocationCityDatabaseFile() != null) {</span>
            // copy embedded resource to destination file
<span class="fc" id="L525">            copyResource(mConfiguration.getIPGeolocationCityEmbeddedResource(),</span>
<span class="fc" id="L526">                    mConfiguration.getIPGeolocationCityDatabaseFile());</span>
<span class="fc" id="L527">            return true;</span>
        }

<span class="nc" id="L530">        return false;</span>
    }

    /**
     * Copies country city resource into destination file where database will
     * be stored locally.
     *
     * @return true if database was prepared, false otherwise.
     * @throws IOException if an I/O error occurs.
     */
    private boolean prepareCountryDatabase() throws IOException {
<span class="pc bpc" id="L541" title="1 of 2 branches missed.">        if (mConfiguration.isIPGeolocationCountryDatabaseEmbedded() &amp;&amp;</span>
<span class="pc bpc" id="L542" title="1 of 2 branches missed.">                mConfiguration.getIPGeolocationCountryEmbeddedResource() != null &amp;&amp;</span>
<span class="pc bpc" id="L543" title="1 of 2 branches missed.">                mConfiguration.getIPGeolocationCountryDatabaseFile() != null) {</span>
            // copy embedded resource to destination file
<span class="fc" id="L545">            copyResource(mConfiguration.getIPGeolocationCountryEmbeddedResource(),</span>
<span class="fc" id="L546">                    mConfiguration.getIPGeolocationCountryDatabaseFile());</span>
<span class="fc" id="L547">            return true;</span>
        }

<span class="nc" id="L550">        return false;</span>
    }

    /**
     * Copies a given resource embedded in code into provided destination file.
     * If file where data is to be stored does not exist, a new one will be
     * created. If it already exists, it will be overwritten.
     *
     * @param resource resource to read data from.
     * @param file     file to store data.
     * @throws IOException .
     */
    private void copyResource(final String resource, final String file) throws IOException {
<span class="fc" id="L563">        final File f = new File(file);</span>
<span class="fc" id="L564">        final File parent = f.getParentFile();</span>
        // attempt to create parent folders if they don't exist
<span class="pc bpc" id="L566" title="2 of 6 branches missed.">        if (parent != null &amp;&amp; !parent.exists() &amp;&amp; !parent.mkdirs()) {</span>
<span class="nc" id="L567">            throw new IOException();</span>
        }

<span class="fc bfc" id="L570" title="All 2 branches covered.">        if (!f.exists()) {</span>
<span class="fc" id="L571">            try (final InputStream inStream = IPGeolocator.class.getResourceAsStream(resource)) {</span>
<span class="fc" id="L572">                try (final OutputStream outStream = new FileOutputStream(file)) {</span>
<span class="fc" id="L573">                    LOGGER.log(Level.INFO, &quot;Copying resource: {0}&quot;, resource);</span>


<span class="fc" id="L576">                    final byte[] buffer = new byte[BUFFER_SIZE];</span>
                    int n;
<span class="fc bfc" id="L578" title="All 2 branches covered.">                    while ((n = inStream.read(buffer)) &gt; 0) {</span>
<span class="fc" id="L579">                        outStream.write(buffer, 0, n);</span>
                    }
<span class="fc" id="L581">                    LOGGER.log(Level.INFO, &quot;Resource: {0} copied to {1}&quot;,</span>
<span class="fc" id="L582">                            new Object[]{resource, f.getAbsolutePath()});</span>
                }
            }
        }
<span class="fc" id="L586">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>