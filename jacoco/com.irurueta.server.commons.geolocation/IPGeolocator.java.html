<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IPGeolocator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-server-commons-geolocation</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.server.commons.geolocation</a> &gt; <span class="el_source">IPGeolocator.java</span></div><h1>IPGeolocator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2016 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.server.commons.geolocation;

import com.maxmind.db.CHMCache;
import com.maxmind.geoip2.DatabaseReader;
import com.maxmind.geoip2.model.AbstractCountryResponse;
import com.maxmind.geoip2.model.CityResponse;
import com.maxmind.geoip2.record.City;
import com.maxmind.geoip2.record.Continent;
import com.maxmind.geoip2.record.Country;
import com.maxmind.geoip2.record.Location;
import com.maxmind.geoip2.record.Postal;
import com.maxmind.geoip2.record.Subdivision;
import com.maxmind.geoip2.record.Traits;

import java.io.Closeable;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.ref.SoftReference;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.List;
import java.util.TimeZone;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Class to locate an IP address.
 */
public class IPGeolocator implements Closeable {

    /**
     * Logger of this class.
     */
<span class="fc" id="L54">    private static final Logger LOGGER = Logger.getLogger(</span>
<span class="fc" id="L55">            IPGeolocator.class.getName());</span>

    /**
     * Buffer size to copy embedded databases into final locations.
     */
    private static final int BUFFER_SIZE = 1024;

    /**
     * Singleton instance of IPGeolocator.
     */
    private static SoftReference&lt;IPGeolocator&gt; mReference;

    /**
     * Indicates if geolocation is enabled.
     */
    private boolean mEnabled;

    /**
     * Reference to geolocation configuration.
     */
    private GeolocationConfiguration mConfiguration;

    /**
     * City database reader.
     */
    private DatabaseReader mCityReader;

    /**
     * Indicates whether city database has already been prepared.
     */
    private boolean mCityDatabasePrepared;

    /**
     * Country database reader.
     */
    private DatabaseReader mCountryReader;

    /**
     * Indicates whether country database has already been prepared.
     */
    private boolean mCountryDatabasePrepared;

    /**
     * Constructor.
     * Creates and configures an IPGeolocator instance.
     */
<span class="fc" id="L101">    private IPGeolocator() {</span>
<span class="fc" id="L102">        mEnabled = false;</span>
        try {
<span class="fc" id="L104">            mConfiguration = GeolocationConfigurationFactory.getInstance().</span>
<span class="fc" id="L105">                    configure();</span>


            // copy embedded databases to destination if needed
<span class="fc" id="L109">            prepareDatabases();</span>

            // configure lookup services
<span class="fc" id="L112">            final IPGeolocationLevel level = mConfiguration.getIPGeolocationLevel();</span>

<span class="pc bpc" id="L114" title="1 of 2 branches missed.">            if (level != null) {</span>
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">                if (level == IPGeolocationLevel.CITY) {</span>
<span class="fc" id="L116">                    mCityReader = createCityReader();</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">                } else if (level == IPGeolocationLevel.COUNTRY) {</span>
<span class="nc" id="L118">                    mCountryReader = createCountryReader();</span>
                }

<span class="pc bpc" id="L121" title="3 of 4 branches missed.">                if (mCityReader != null || mCountryReader != null) {</span>
<span class="fc" id="L122">                    mEnabled = true;</span>
                }
            }

<span class="pc bpc" id="L126" title="1 of 2 branches missed.">            if (mEnabled) {</span>
<span class="fc" id="L127">                LOGGER.log(Level.INFO, &quot;IP geolocation configured&quot;);</span>
            } else {
<span class="nc" id="L129">                LOGGER.log(Level.INFO, &quot;IP geolocation is disabled&quot;);</span>
            }
<span class="nc" id="L131">        } catch (final Exception e) {</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">            if (mEnabled) {</span>
<span class="nc" id="L133">                LOGGER.log(Level.INFO, &quot;IP geolocation configured&quot;, e);</span>
            } else {
<span class="nc" id="L135">                LOGGER.log(Level.INFO, &quot;IP geolocation is disabled&quot;, e);</span>
            }
<span class="fc" id="L137">        }</span>
<span class="fc" id="L138">    }</span>

    /**
     * Factory method to return the singleton instance of IPGeolocator based
     * on current configuration.
     *
     * @return singleton instance.
     */
    public static synchronized IPGeolocator getInstance() {
        IPGeolocator singleton;
<span class="pc bpc" id="L148" title="1 of 4 branches missed.">        if (mReference == null || (singleton = mReference.get()) == null) {</span>
<span class="fc" id="L149">            singleton = new IPGeolocator();</span>
<span class="fc" id="L150">            mReference = new SoftReference&lt;&gt;(singleton);</span>
        }
<span class="fc" id="L152">        return singleton;</span>
    }

    /**
     * Locates provided IP or IPv6 address using requested level.
     * Notice that geolocation levels are: Country, City (which includes country
     * information) and Disabled, which throws an exception.
     *
     * @param address IP address to evaluate.
     * @param level   level of accuracy of geolocation.
     * @return location of IP address.
     * @throws IPGeolocationDisabledException if IP geolocation is disabled or
     *                                        was not properly configured.
     * @throws IPLocationNotFoundException    if IP address couldn't be geolocated
     *                                        because it wasn't found in database.
     */
    public synchronized IPLocation locate(
            final InetAddress address,
            final IPGeolocationLevel level) throws IPGeolocationDisabledException,
            IPLocationNotFoundException {
<span class="pc bpc" id="L172" title="1 of 4 branches missed.">        if (!mEnabled || level == IPGeolocationLevel.DISABLED) {</span>
<span class="fc" id="L173">            throw new IPGeolocationDisabledException();</span>
        }

        try {
<span class="fc" id="L177">            final IPLocation location = new IPLocation(level);</span>
<span class="fc" id="L178">            boolean found = false;</span>
            DatabaseReader reader;

            // city level
<span class="fc bfc" id="L182" title="All 2 branches covered.">            if (level == IPGeolocationLevel.CITY) {</span>
<span class="fc" id="L183">                reader = getOrCreateCityReader();</span>

                // search at city level
<span class="fc" id="L186">                final CityResponse response = reader.city(address);</span>
<span class="pc bpc" id="L187" title="1 of 2 branches missed.">                if (response != null) {</span>
<span class="fc" id="L188">                    found = true;</span>

                    // city level
<span class="fc" id="L191">                    final City city = response.getCity();</span>
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">                    if (city != null) {</span>
<span class="fc" id="L193">                        location.mCity = city.getName();</span>
                    }

<span class="fc" id="L196">                    final Location loc = response.getLocation();</span>
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">                    if (loc != null) {</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">                        location.mTimeZone = loc.getTimeZone() != null ?</span>
<span class="fc" id="L199">                                TimeZone.getTimeZone(loc.getTimeZone()) : null;</span>
<span class="fc" id="L200">                        location.mAccuracyRadius = loc.getAccuracyRadius();</span>
<span class="fc" id="L201">                        location.mMetroCode = loc.getMetroCode();</span>
<span class="fc" id="L202">                        location.mLatitude = loc.getLatitude();</span>
<span class="fc" id="L203">                        location.mLongitude = loc.getLongitude();</span>
                    }

<span class="fc" id="L206">                    final Postal postal = response.getPostal();</span>
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">                    if (postal != null) {</span>
<span class="fc" id="L208">                        location.mPostalCode = postal.getCode();</span>
                    }

<span class="fc" id="L211">                    final List&lt;Subdivision&gt; subdivisions = response.getSubdivisions();</span>
<span class="pc bpc" id="L212" title="1 of 2 branches missed.">                    if (subdivisions != null) {</span>
<span class="fc" id="L213">                        location.mSubdivisionCodes = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L214">                        location.mSubdivisionNames = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L215" title="All 2 branches covered.">                        for (final Subdivision s : subdivisions) {</span>
<span class="pc bpc" id="L216" title="2 of 4 branches missed.">                            if (s.getIsoCode() != null &amp;&amp; s.getName() != null) {</span>
<span class="fc" id="L217">                                location.mSubdivisionCodes.add(s.getIsoCode());</span>
<span class="fc" id="L218">                                location.mSubdivisionNames.add(s.getName());</span>
                            }
<span class="fc" id="L220">                        }</span>
                    }


                    // country level
<span class="fc" id="L225">                    processCountryResponse(response, location);</span>
                }
            }

            // country or city level (if nothing has been found yet)
<span class="fc bfc" id="L230" title="All 2 branches covered.">            if (level == IPGeolocationLevel.COUNTRY) {</span>
<span class="fc" id="L231">                reader = getOrCreateCountryReader();</span>
<span class="fc" id="L232">                final AbstractCountryResponse response = reader.country(address);</span>
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">                found = response != null;</span>
<span class="fc" id="L234">                processCountryResponse(response, location);</span>
            }

<span class="pc bpc" id="L237" title="1 of 2 branches missed.">            if (!found) {</span>
<span class="nc" id="L238">                throw new IPLocationNotFoundException();</span>
            }

<span class="fc" id="L241">            return location;</span>
<span class="fc" id="L242">        } catch (final Exception e) {</span>
<span class="fc" id="L243">            throw new IPLocationNotFoundException(e);</span>
        }
    }

    /**
     * Locates provided IP or IPv6 address using requested level.
     * Notice that geolocation levels are: Country, City (which includes country
     * information) and Organization (which includes both City and Country
     * information)
     *
     * @param address IP address or DNS host name to evaluate in string form.
     * @param level   level of accuracy of geolocation.
     * @return location of IP address.
     * @throws UnknownHostException           if provided textual form of IP address is
     *                                        not valid, or if DNS host name couldn't be resolved into an IP address.
     * @throws IPGeolocationDisabledException if IP geolocation is disabled or
     *                                        was not properly configured.
     * @throws IPLocationNotFoundException    if IP address couldn't be geolocated
     *                                        because it wasn't found in database.
     */
    public IPLocation locate(final String address, final IPGeolocationLevel level)
            throws UnknownHostException, IPGeolocationDisabledException,
            IPLocationNotFoundException {
<span class="fc" id="L266">        return locate(InetAddress.getByName(address), level);</span>
    }

    /**
     * Locates provided IP or IPv6 address using default configured geolocation
     * level of accuracy.
     *
     * @param address IP address to evaluate.
     * @return location of IP address.
     * @throws IPGeolocationDisabledException if IP geolocation is disabled or
     *                                        was not properly configured.
     * @throws IPLocationNotFoundException    if IP address couldn't be geolocated
     *                                        because it wasn't found in database.
     */
    public IPLocation locate(final InetAddress address)
            throws IPGeolocationDisabledException, IPLocationNotFoundException {
<span class="fc" id="L282">        return locate(address, mConfiguration.getIPGeolocationLevel());</span>
    }

    /**
     * Locates provided IP or IPv6 address using default configured geolocation
     * level of accuracy.
     *
     * @param address IP address or DNS host name to evaluate in string form
     * @return location of IP address.
     * @throws UnknownHostException           if provided textual form of IP address is
     *                                        not valid, or if DNS host name couldn't be resolved into an IP address.
     * @throws IPGeolocationDisabledException if IP geolocation is disabled or
     *                                        was not properly configured.
     * @throws IPLocationNotFoundException    if IP address couldn't be geolocated
     *                                        because it wasn't found in database.
     */
    public IPLocation locate(final String address) throws UnknownHostException,
            IPGeolocationDisabledException, IPLocationNotFoundException {
<span class="fc" id="L300">        return locate(InetAddress.getByName(address));</span>
    }

    /**
     * Closes location services. Once closed, geolocation will not be available.
     * If databases where embedded, then their destination local files will also
     * be deleted when closing location services.
     * This method should be called at server shutdown or when application is
     * undeployed.
     *
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public synchronized void close() throws IOException {
        // close location services
<span class="fc bfc" id="L315" title="All 2 branches covered.">        if (mCityReader != null) {</span>
            try {
<span class="fc" id="L317">                mCityReader.close();</span>
<span class="nc" id="L318">            } catch (final IOException e) {</span>
<span class="nc" id="L319">                LOGGER.log(Level.WARNING, &quot;Could not close city database&quot;, e);</span>
<span class="fc" id="L320">            }</span>
        }
<span class="fc bfc" id="L322" title="All 2 branches covered.">        if (mCountryReader != null) {</span>
            try {
<span class="fc" id="L324">                mCountryReader.close();</span>
<span class="nc" id="L325">            } catch (final IOException e) {</span>
<span class="nc" id="L326">                LOGGER.log(Level.WARNING, &quot;Could not close country database&quot;, e);</span>
<span class="fc" id="L327">            }</span>
        }

<span class="fc" id="L330">        mEnabled = false;</span>

        // delete database files if they were copied from embedded resources, as
        // this method will usually be called on server shutdown or application
        // undeployment
<span class="fc" id="L335">        boolean failed = false;</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">        if (mCountryDatabasePrepared) {</span>
            // delete country database file
<span class="fc" id="L338">            final File f = new File(</span>
<span class="fc" id="L339">                    mConfiguration.getIPGeolocationCountryDatabaseFile());</span>
<span class="fc bfc" id="L340" title="All 2 branches covered.">            if (f.exists()) {</span>
                try {
<span class="fc" id="L342">                    Files.delete(f.toPath());</span>
<span class="nc" id="L343">                } catch (final IOException e) {</span>
<span class="nc" id="L344">                    failed = true;</span>
<span class="fc" id="L345">                }</span>
            }
        }

        //city database
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">        if (mCityDatabasePrepared) {</span>
            //delete city database file
<span class="fc" id="L352">            final File f = new File(</span>
<span class="fc" id="L353">                    mConfiguration.getIPGeolocationCityDatabaseFile());</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">            if (f.exists()) {</span>
                try {
<span class="fc" id="L356">                    Files.delete(f.toPath());</span>
<span class="nc" id="L357">                } catch (final IOException e) {</span>
<span class="nc" id="L358">                    failed = true;</span>
<span class="fc" id="L359">                }</span>
            }
        }

<span class="fc" id="L363">        mCityReader = mCountryReader = null;</span>

<span class="pc bpc" id="L365" title="1 of 2 branches missed.">        if (failed) {</span>
<span class="nc" id="L366">            throw new IOException();</span>
        }
<span class="fc" id="L368">    }</span>

    /**
     * Closes geolocation services if a configured IPGeolocator exists, and
     * resets the current singleton instance so a new one can be acquired having
     * a new configuration if required.
     *
     * @throws IOException if an I/O error occurs.
     */
    protected static synchronized void reset() throws IOException {
        final IPGeolocator singleton;
<span class="pc bpc" id="L379" title="1 of 4 branches missed.">        if (mReference != null &amp;&amp; (singleton = mReference.get()) != null) {</span>
<span class="fc" id="L380">            singleton.close();</span>
        }
<span class="fc" id="L382">        mReference = null;</span>
<span class="fc" id="L383">    }</span>

    /**
     * This method is called on garbage collection.
     * When this method is called, all the location services of this instance
     * will be closed, and the files where embedded databases were copied will
     * be deleted.
     *
     * @throws Throwable if anything fails.
     */
    @Override
    protected void finalize() throws Throwable {
<span class="nc" id="L395">        close();</span>
<span class="nc" id="L396">        super.finalize();</span>
<span class="nc" id="L397">    }</span>

    /**
     * Gets or create city database reader.
     *
     * @return city database reader.
     * @throws IOException if an I/O error occurs.
     */
    private DatabaseReader getOrCreateCityReader() throws IOException {
<span class="pc bpc" id="L406" title="1 of 2 branches missed.">        if (mCityReader != null) {</span>
<span class="fc" id="L407">            return mCityReader;</span>
        } else {
<span class="nc" id="L409">            mCityReader = createCityReader();</span>
        }

<span class="nc" id="L412">        return mCityReader;</span>
    }

    /**
     * Gets or creates country database reader.
     *
     * @return country database reader.
     * @throws IOException if an I/O error occurs.
     */
    private DatabaseReader getOrCreateCountryReader() throws IOException {
<span class="fc bfc" id="L422" title="All 2 branches covered.">        if (mCountryReader != null) {</span>
<span class="fc" id="L423">            return mCountryReader;</span>
        } else {
<span class="fc" id="L425">            mCountryReader = createCountryReader();</span>
        }

<span class="fc" id="L428">        return mCountryReader;</span>
    }

    /**
     * Creates a city database reader.
     *
     * @return a city database reader.
     * @throws IOException if an I/O error occurs.
     */
    private DatabaseReader createCityReader() throws IOException {
<span class="pc bpc" id="L438" title="1 of 2 branches missed.">        if (!mCityDatabasePrepared) {</span>
<span class="nc" id="L439">            mCityDatabasePrepared = prepareCityDatabase();</span>
        }
<span class="fc" id="L441">        final File f = new File(mConfiguration.getIPGeolocationCityDatabaseFile());</span>
<span class="fc" id="L442">        return createReader(f);</span>
    }

    /**
     * Creates a country database reader.
     *
     * @return a country database reader.
     * @throws IOException if an I/O error occurs.
     */
    private DatabaseReader createCountryReader() throws IOException {
<span class="pc bpc" id="L452" title="1 of 2 branches missed.">        if (!mCountryDatabasePrepared) {</span>
<span class="fc" id="L453">            mCountryDatabasePrepared = prepareCountryDatabase();</span>
        }
<span class="fc" id="L455">        final File f = new File(mConfiguration.getIPGeolocationCountryDatabaseFile());</span>
<span class="fc" id="L456">        return createReader(f);</span>
    }

    /**
     * Creates a database reader.
     *
     * @param file file to read database from.
     * @return a database reader.
     * @throws IOException if an I/O error occurs.
     */
    private DatabaseReader createReader(final File file) throws IOException {
<span class="fc" id="L467">        final boolean cachingEnabled = mConfiguration.isCachingEnabled();</span>

<span class="fc" id="L469">        final DatabaseReader.Builder builder =</span>
                new DatabaseReader.Builder(file);
<span class="pc bpc" id="L471" title="1 of 2 branches missed.">        if (cachingEnabled) {</span>
<span class="fc" id="L472">            builder.withCache(new CHMCache());</span>
        }
<span class="fc" id="L474">        return builder.build();</span>
    }

    /**
     * Processes country level location data.
     *
     * @param response a response being processed.
     * @param location location where result will be stored.
     */
    private void processCountryResponse(final AbstractCountryResponse response,
                                        final IPLocation location) {
<span class="pc bpc" id="L485" title="2 of 4 branches missed.">        if (response == null || location == null) {</span>
<span class="nc" id="L486">            return;</span>
        }

<span class="fc" id="L489">        final Continent continent = response.getContinent();</span>
<span class="pc bpc" id="L490" title="1 of 2 branches missed.">        if (continent != null) {</span>
<span class="fc" id="L491">            location.mContinentCode = continent.getCode();</span>
<span class="fc" id="L492">            location.mContinentName = continent.getName();</span>
        }

<span class="fc" id="L495">        Country country = response.getCountry();</span>
<span class="pc bpc" id="L496" title="1 of 2 branches missed.">        if (country != null) {</span>
<span class="fc" id="L497">            location.mCountryCode = country.getIsoCode();</span>
<span class="fc" id="L498">            location.mCountryName = country.getName();</span>
        }
<span class="fc" id="L500">        country = response.getRegisteredCountry();</span>
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">        if (country != null) {</span>
<span class="fc" id="L502">            location.mRegisteredCountryCode = country.getIsoCode();</span>
<span class="fc" id="L503">            location.mRegisteredCountryName = country.getName();</span>
        }

<span class="fc" id="L506">        final Traits traits = response.getTraits();</span>
<span class="pc bpc" id="L507" title="1 of 2 branches missed.">        if (traits != null) {</span>
<span class="fc" id="L508">            location.mAutonomousSystemNumber =</span>
<span class="fc" id="L509">                    traits.getAutonomousSystemNumber();</span>
<span class="fc" id="L510">            location.mDomain = traits.getDomain();</span>
<span class="fc" id="L511">            location.mIsp = traits.getIsp();</span>
<span class="fc" id="L512">            location.mOrganization = traits.getOrganization();</span>
        }
<span class="fc" id="L514">    }</span>

    /**
     * Copies embedded resources into destination files where databases will be
     * stored locally.
     *
     * @throws IOException if an I/O error occurs.
     */
    private void prepareDatabases() throws IOException {

        // city database
<span class="fc" id="L525">        final IPGeolocationLevel level = mConfiguration.getIPGeolocationLevel();</span>
<span class="pc bpc" id="L526" title="1 of 2 branches missed.">        if (level == IPGeolocationLevel.CITY &amp;&amp;</span>
<span class="pc bpc" id="L527" title="1 of 2 branches missed.">                mConfiguration.isIPGeolocationCityDatabaseEmbedded() &amp;&amp;</span>
<span class="pc bpc" id="L528" title="1 of 2 branches missed.">                mConfiguration.getIPGeolocationCityEmbeddedResource() != null &amp;&amp;</span>
<span class="pc bpc" id="L529" title="1 of 2 branches missed.">                mConfiguration.getIPGeolocationCityDatabaseFile() != null) {</span>
<span class="fc" id="L530">            mCityDatabasePrepared = prepareCityDatabase();</span>
        }

        // country database
<span class="pc bpc" id="L534" title="1 of 2 branches missed.">        if (!mCityDatabasePrepared &amp;&amp;</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">                mConfiguration.isIPGeolocationCountryDatabaseEmbedded() &amp;&amp;</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">                mConfiguration.getIPGeolocationCountryEmbeddedResource() != null &amp;&amp;</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">                mConfiguration.getIPGeolocationCountryDatabaseFile() != null) {</span>
<span class="nc" id="L538">            mCountryDatabasePrepared = prepareCountryDatabase();</span>
        }
<span class="fc" id="L540">    }</span>

    /**
     * Copies embedded city resource into destination file where database will
     * be stored locally.
     *
     * @return true if database was prepared, false otherwise.
     * @throws IOException if an I/O error occurs.
     */
    private boolean prepareCityDatabase() throws IOException {
<span class="pc bpc" id="L550" title="1 of 2 branches missed.">        if (mConfiguration.isIPGeolocationCityDatabaseEmbedded() &amp;&amp;</span>
<span class="pc bpc" id="L551" title="1 of 2 branches missed.">                mConfiguration.getIPGeolocationCityEmbeddedResource() != null &amp;&amp;</span>
<span class="pc bpc" id="L552" title="1 of 2 branches missed.">                mConfiguration.getIPGeolocationCityDatabaseFile() != null) {</span>
            // copy embedded resource to destination file
<span class="fc" id="L554">            copyResource(mConfiguration.getIPGeolocationCityEmbeddedResource(),</span>
<span class="fc" id="L555">                    mConfiguration.getIPGeolocationCityDatabaseFile());</span>
<span class="fc" id="L556">            return true;</span>
        }

<span class="nc" id="L559">        return false;</span>
    }

    /**
     * Copies country city resource into destination file where database will
     * be stored locally.
     *
     * @return true if database was prepared, false otherwise.
     * @throws IOException if an I/O error occurs.
     */
    private boolean prepareCountryDatabase() throws IOException {
<span class="pc bpc" id="L570" title="1 of 2 branches missed.">        if (mConfiguration.isIPGeolocationCountryDatabaseEmbedded() &amp;&amp;</span>
<span class="pc bpc" id="L571" title="1 of 2 branches missed.">                mConfiguration.getIPGeolocationCountryEmbeddedResource() != null &amp;&amp;</span>
<span class="pc bpc" id="L572" title="1 of 2 branches missed.">                mConfiguration.getIPGeolocationCountryDatabaseFile() != null) {</span>
            // copy embedded resource to destination file
<span class="fc" id="L574">            copyResource(mConfiguration.getIPGeolocationCountryEmbeddedResource(),</span>
<span class="fc" id="L575">                    mConfiguration.getIPGeolocationCountryDatabaseFile());</span>
<span class="fc" id="L576">            return true;</span>
        }

<span class="nc" id="L579">        return false;</span>
    }

    /**
     * Copies a given resource embedded in code into provided destination file.
     * If file where data is to be stored does not exist, a new one will be
     * created. If it already exists, it will be overwritten.
     *
     * @param resource resource to read data from.
     * @param file     file to store data.
     * @throws IOException .
     */
    private void copyResource(final String resource, final String file) throws IOException {
<span class="fc" id="L592">        final File f = new File(file);</span>
<span class="fc" id="L593">        final File parent = f.getParentFile();</span>
<span class="pc bpc" id="L594" title="1 of 4 branches missed.">        if (parent != null &amp;&amp; !parent.exists()) {</span>
            // attempt to create parent folders if they don't exist
<span class="pc bpc" id="L596" title="1 of 2 branches missed.">            if (!parent.mkdirs()) {</span>
<span class="nc" id="L597">                throw new IOException();</span>
            }
        }

<span class="pc bpc" id="L601" title="1 of 2 branches missed.">        if (!f.exists()) {</span>
<span class="fc" id="L602">            try (final InputStream inStream = IPGeolocator.class.getResourceAsStream(resource)) {</span>
<span class="fc" id="L603">                try (final OutputStream outStream = new FileOutputStream(file)) {</span>
<span class="fc" id="L604">                    LOGGER.log(Level.INFO, &quot;Copying resource: {0}&quot;, resource);</span>


<span class="fc" id="L607">                    final byte[] buffer = new byte[BUFFER_SIZE];</span>
                    int n;
<span class="fc bfc" id="L609" title="All 2 branches covered.">                    while ((n = inStream.read(buffer)) &gt; 0) {</span>
<span class="fc" id="L610">                        outStream.write(buffer, 0, n);</span>
                    }
<span class="fc" id="L612">                    LOGGER.log(Level.INFO, &quot;Resource: {0} copied to {1}&quot;,</span>
<span class="fc" id="L613">                            new Object[]{resource, f.getAbsolutePath()});</span>
                }
            }
        }
<span class="fc" id="L617">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>